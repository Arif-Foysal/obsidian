Several computer systems have historically used or continue to use CISC architecture. Here are some examples:
Several computer systems have historically used or continue to use CISC architecture. Here are some examples:

1. x86: The x86 architecture, developed by Intel and AMD, is one of the most widely used CISC architectures. It powers the majority of personal computers and servers globally. Variants of x86 architecture include Intel's 8086, 80286, 80386, Pentium, Core, and AMD's Athlon and Ryzen processors.

2. x86-64 (or AMD64): This is an extension of the x86 architecture introduced by AMD, which added 64-bit support to the existing x86 instruction set. It is now the dominant architecture for 64-bit desktop and server systems, including Intel's and AMD's 64-bit processors.

3. IBM System/360 and z/Architecture: IBM's mainframe architectures, starting with the System/360, use CISC instruction sets. The modern IBM z/Architecture, found in IBM's zSeries mainframe computers, retains CISC characteristics, such as variable-length instructions and hardware optimization.

4. VAX: The VAX (Virtual Address eXtension) architecture developed by Digital Equipment Corporation (DEC) was a popular CISC architecture in the 1970s and 1980s. VAX systems were widely used in scientific, engineering, and business applications.

5. Motorola 68k: The Motorola 68000 series of processors, commonly known as 68k, utilized a CISC instruction set. These processors were used in early personal computers, such as the Apple Macintosh, as well as in embedded systems and workstations.

6. DEC Alpha: The DEC Alpha architecture, also known as Alpha AXP, was developed by DEC and later acquired by Compaq and Hewlett-Packard. Alpha processors featured a 64-bit CISC instruction set and were used in high-performance computing and workstation applications.

While these examples highlight CISC architectures, it's important to note that modern processors often incorporate a combination of CISC and RISC features. This hybrid approach aims to leverage the benefits of both architectures to achieve a balance between instruction complexity and performance optimization.